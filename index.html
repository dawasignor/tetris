<!DOCTYPE html>
<html>

<head>
  <title>Tetris Example</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet">

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
  <link rel="stylesheet" href="tetris.css">

  <script type="text/javascript" src="background.js"></script>
  <script type="text/javascript" src="logic.js"></script>

  <script type="text/javascript" src="constants.js"></script>

</head>

<body>
  <div class="container-fluid p-0">
    <div class="row align-items-start">
      <div id="box1" style="height: 100vh; width: 25vw; background-color:#FF6B6B ;">
        Score: <p id="Score"></p>
      </div>
      <div id="left-wall" style="background-color:black; height: 100vh; width: 5vw;">
      </div>
      <div class="centerBox "
        style=" background-color:  #9723C9 ;height: 100vh; width: 39.6vw; padding-left: 0px; padding-right: 0px;">
        <canvas id="play-area" class="board"></canvas>
        <div
          style="background-color:black; position: absolute; top: 92.5vh; left: 29.1vw; height: 5vh; width: 39.7vw; border-style: dashed; border-width: 1px; padding-left: 0px;">
        </div>
      </div>
      <div id="right-wall" style="background-color:black; height: 100vh; width: 5vw;">
      </div>

      <div class="box3" style=" height: 100vh; width: 25vw; background-color:#FF6B6B;">
        Press Enter to start!
        </br>
        TODO : Leader Board will come here
      </div>
    </div>
  </div>


</body>
<script>
  //constant.js --- parameterized
  // import startColumn from './constants.js'
  // console.log(startColumn);
  const startColumn = 1;
  const leftWallVW = 30;
  const horizontalUnit = 4;
  const verticalUnit = 8;//TODO var vs let vs const
  const COLS = 18;
  const ROWS = 20;

  const SCALE_FACTOR = 30;
  const BLOCK_HEIGHT = 1;
  const BLOCK_WIDTH = 1;

  let orientation = 1;

  const ctx = document.getElementById("play-area").getContext('2d');

  ctx.canvas.width = COLS * SCALE_FACTOR;
  ctx.canvas.height = ROWS * SCALE_FACTOR;

  ctx.scale(SCALE_FACTOR, SCALE_FACTOR);
  ctx.lineWidth = 0.1;
  // ctx.fillStyle = '#87CEEB';
  // ctx.roundRect(5, 5, BLOCK_WIDTH, BLOCK_HEIGHT,[0.1]);
  // ctx.stroke();
  // ctx.fill();
  ctx.fillRect(COLS - 1, 0, BLOCK_WIDTH, BLOCK_HEIGHT);
  ctx.fillRect(COLS - 1, ROWS - 1, BLOCK_WIDTH, BLOCK_HEIGHT);
  ctx.fillRect(0, ROWS - 1, BLOCK_WIDTH, BLOCK_HEIGHT);
  console.log(screen.width);
  console.log(screen.height);
  console.log(give);



  let row = 1;
  let blockType = 0;
  let gameOver = false;
  let col = 1;
  let floor = 10

  var lattice;
  lattice = initLattice(ROWS, COLS);
  let floorArray = [10, 10, 10, 10, 10, 10, 10, 10, 10, 10]
  let ActiveBlockId = 1;
  let activeBlock = document.querySelector(".active-block");
  var gameStart = 0;
  let activeBlockLattice;

  drawbg(lattice);


  function start() {
    gameStart = setInterval(moveblockDown, 1000);
    updateScore()
  }
  function end() {
    gameOver = true;
    console.log("GAMEOVER!");
    const gameOverDiv = document.createElement("div");
    gameOverDiv.innerHTML = "<h3>GAME OVER!</h3>";
    document.getElementById("box1").append(gameOverDiv);
    document.getElementById("Score").innerHTML = "<h3>" + (ActiveBlockId - 1) + "</h3>";
    clearInterval(gameTime);
    clearInterval(gameStart);
  }

  function updateScore() {
    document.getElementById("Score").innerHTML = "<h3>" + (ActiveBlockId - 1) + "</h3>";
  }

  const gameTime = setInterval(refreshBlock, 100);



  window.addEventListener("keydown", keyboardContoller, false);
  updateActiveBlock();

  function refreshBlock() {
    if (!canMoveDown()) {
      updateActiveBlock();
    }
  }
  function isGameOver() {
    if (canMoveDown()) {
      return false;
    } else {
      end();
      return true;
    }
  }
  function keyboardContoller(evt) {
    event.preventDefault();

    switch (evt.key) {
      case "ArrowLeft":
        if (col > 1 && !gameOver && canMoveSide("left")) {
          updateLattice_side("left");
          col -= 1;
          //moveblockSide("left");
          activeBlock.style.left = "" + (leftWallVW + (col - 1) * 4) + "vw"; //only if type = square
        }
        break;
      case "ArrowRight":
        if (col <= COLS - 1 && !gameOver && canMoveSide("right")) {
          updateLattice_side("right");
          col += 1; //add move dynamically
          //moveblockSide("right");
          activeBlock.style.left = "" + (leftWallVW + (col - 1) * 4) + "vw"; //only if type = square
        }
        break;
      case "ArrowDown":
        if (!gameOver) {
          setTimeout(refreshBlock, 10);
          moveblockDown();
        }
        break;
      case "Enter":
        if (ActiveBlockId == 2) {
          start();
        }
        break;
      case " ":
        console.log("in space");
        rotateBlockLattice();
        break;
    }


  }
  function updateBlockID() {

    console.log("ID = " + activeBlock.id);

  }





  //update lattice
  function updateActiveBlock() {





    console.log(floorArray);

    el = document.querySelector(".active-block");
    if (el != null) { el.classList.remove("active-block") }
    //randomly call shapes
    //shape 5
    //
    ////
    //
    blockType = addBlock();
    console.log(blockType);
    el = document.querySelector(".active-block");
    ActiveBlockId++;
    activeBlock = document.querySelector(".active-block");
    updateBlockID();
    updateScore();
    col = 1;
    row = 1;
    orientation = 1;
    updateLattice_newBlock();
    isGameOver()
    drawbg(lattice);


  }

  function moveblockDown() {
    if (canMoveDown()) {
      updateLattice_down();
      row++;
      drawbg(lattice);
    } else {
      refreshBlock();
    }
  }



  function getArrayforBlock(type, block_rotation) {
    let blockLattice = [];
    switch (type) {
      case 1:
        blockLattice[0] = [1, 1];
        blockLattice[1] = [1, 1];
        break;
      case 2:
        switch (block_rotation % 4) {
          case 1:
          case 3:
            blockLattice[0] = [1, 0, 0, 0];
            blockLattice[1] = [1, 0, 0, 0];
            blockLattice[2] = [1, 0, 0, 0];
            blockLattice[3] = [1, 0, 0, 0];
            break;

          case 2:
          case 0:
            blockLattice[0] = [1, 1, 1, 1];
            blockLattice[1] = [0, 0, 0, 0];
            blockLattice[2] = [0, 0, 0, 0];
            blockLattice[3] = [0, 0, 0, 0];
            break;
        }

        break;
      case 3:
        switch (block_rotation % 4) {
          case 1:
            blockLattice[0] = [1, 0, 0];
            blockLattice[1] = [1, 0, 0];
            blockLattice[2] = [1, 1, 0];
            break;
          case 2:
            blockLattice[0] = [1, 1, 1];
            blockLattice[1] = [1, 0, 0];
            blockLattice[2] = [0, 0, 0];
            break;
          case 3:
            blockLattice[0] = [0, 1, 1];
            blockLattice[1] = [0, 0, 1];
            blockLattice[2] = [0, 0, 1];
            break;
          case 0:
            blockLattice[0] = [0, 0, 1];
            blockLattice[1] = [1, 1, 1];
            blockLattice[2] = [0, 0, 0];
            break;
        }
        break;
      case 4:
        switch (block_rotation % 4) {
          case 1:
            blockLattice[0] = [1, 0, 0];
            blockLattice[1] = [1, 1, 0];
            blockLattice[2] = [1, 0, 0];
            break;
          case 2:
            blockLattice[0] = [1, 1, 1];
            blockLattice[1] = [0, 1, 0];
            blockLattice[2] = [0, 0, 0];
            break;
          case 3:
            blockLattice[0] = [0, 1, 0];
            blockLattice[1] = [1, 1, 0];
            blockLattice[2] = [0, 1, 0];
            break;
          case 0:
            blockLattice[0] = [0, 1, 0];
            blockLattice[1] = [1, 1, 1];
            blockLattice[2] = [0, 0, 0];
            break;
        }

        break;
    }
    return blockLattice;
  }

  function updateLattice_newBlock() {
    activeBlockLattice = getArrayforBlock(blockType, orientation);
    console.log(row);
    console.log(col);
    for (var i = 0; i < lattice.length; i++) {
      for (var j = 0; j < lattice[i].length; j++) {
        if (i < activeBlockLattice.length) {
          if (j < activeBlockLattice[i].length) {
            lattice[i + row - 1][j + col - 1] = activeBlockLattice[i][j];
          }
        }

      }
    }
    drawbg(lattice);

  }
  function updateLattice_down() {
    let blockLattice = activeBlockLattice;
    blockRowSize = blockLattice.length;
    blockColSize = blockLattice[0].length;
    for (var i = (row + blockRowSize - 2); i >= (row - 1); i--) {
      for (var j = (col - 1); j < (col + blockColSize - 1); j++) {
        console.log("i : " + i + "  j:" + j);
        if (i != ROWS && lattice[i + 1][j] != 1) {
          lattice[i + 1][j] = lattice[i][j];
          lattice[i][j] = 0;
        }
      }
    }
    drawbg(lattice);
  }

  function updateLattice_side(side) {
    let right = side == "right" ? true : false;
    let blockLattice = activeBlockLattice;
    var i, j;
    blockRowSize = blockLattice.length;
    blockColSize = blockLattice[0].length;
    for (i = (row + blockRowSize - 2); i >= (row - 1); i--) {
      if (right) {
        if ((col + blockColSize - 1) < COLS) {
          for (var j = (col + blockColSize - 2); j >= (col - 1); j--) {
            lattice[i][j + 1] = lattice[i][j];
            if (j == (col - 1)) {
              lattice[i][j] = 0;
            }
          }
        }
      } else {
        if (col > 1) {
          for (var j = (col - 1); j <= (col + blockColSize - 2); j++) {
            lattice[i][j - 1] = lattice[i][j];
            if (j == (col + blockColSize - 2)) {
              lattice[i][j] = 0;
            }
          }
        }
      }
    }
    drawbg(lattice);
  }

  function canMoveDown() {
    let result = true;
    let blockLattice = activeBlockLattice;
    let blockLastRowIndex = blockLattice.length - 1;
    let blockLastRow = blockLattice[blockLastRowIndex];
    let toCheckElements = [];
    var i, j;
    for (j = 0; j <= blockLastRow.length; j++) {
      for (i = blockLastRowIndex; i >= 0; i--) {
        if (blockLattice[i][j] == 1) {
          toCheckElements[j] = [i, j];
          break;
        }
        toCheckElements[j] = [-1, -1];
      }
    }

    if (row + blockLattice.length == ROWS) {
      result = false;
      return result;
    } else {
      for (var el = 0; el < blockLastRow.length; el++) {
        var element = toCheckElements[el];
        let i = element[0];
        let j = element[1];
        if (i != -1 && j != -1) {
          if (lattice[row + i][col + j - 1] == 1) {
            result = false;
            break;
          }
        }
      }
    }
    return result;

  }

  function canMoveSide(side) {
    let isRight = side == "right" ? true : false;
    let result = true;
    let blockLattice = activeBlockLattice;
    let blockLastRow = blockLattice[blockLattice.length - 1];
    let blockColSize = blockLastRow.length;
    let blockRowSize = blockLattice.length;
    var i, j;
    if (isRight) {
      lastColIndex = col + blockColSize - 2;
      if (lastColIndex >= COLS - 1) {
        //right wall
        return false;
      }
      else {
        for (i = row - 1; i <= (row + blockRowSize - 2); i++) {
          if (lattice[i][lastColIndex] == 1 && lattice[i][lastColIndex + 1] == 1) {
            //cant move right because of shapes on right.
            return false;
          }
        }
        return true;
      }
    } else {
      lastColIndex = col - 1;
      if (lastColIndex <= 0) {
        //left wall
        return false;
      }
      else {
        for (i = row - 1; i <= (row + blockRowSize - 2); i++) {
          if (lattice[i][lastColIndex] == 1 && lattice[i][lastColIndex - 1] == 1) {
            //cant move right because of shapes on right.
            return false;
          }
        }
        return true;
      }

    }
  }

  function rotateBlockLattice() {
    if (canRotate()) {
      newLattice = getArrayforBlock(blockType, orientation + 1)
      for (var rowT = 0; rowT < newLattice.length; rowT++) {
        for (var colT = 0; colT < newLattice[0].length; colT++) {
          if (activeBlockLattice[rowT][colT] == 1) {
            lattice[row + rowT - 1][col + colT - 1] = 0;
          }
          if (newLattice[rowT][colT] == 1) {
            lattice[row + rowT - 1][col + colT - 1] = 1;
          }
        }
      }
      activeBlockLattice = newLattice;
      orientation++;
      setTimeout(moveblockDown, 1000);
    }


    //store prev lattice
    //get new lattice and orientation and check if its clashing with lattice
    //maybe add canRotate first
  }

  function canRotate() {
    newLattice = getArrayforBlock(blockType, orientation + 1)
    for (var rowT = 0; rowT < newLattice.length; rowT++) {
      for (var colT = 0; colT < newLattice[0].length; colT++) {
        if (lattice[row + rowT - 1][col + colT - 1] == 1 && newLattice[rowT][colT] == 1) {
          if (activeBlockLattice[rowT][colT] == 1) {
            continue;
          } else {
            return false;
          }
        }
      }
    }
    return true;



  }





</script>

</html>